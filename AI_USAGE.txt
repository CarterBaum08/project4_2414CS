Youtube Videos:
https://www.youtube.com/watch?v=2DmK_H7IdTo (HeapSort)
https://www.youtube.com/watch?v=Vtckgz38QHs (QuickSort)


Q: How should I interpret this parameter "long long &exchanges" if it is defined in a function. 
R: I am writing my code/algorithim for the rowSwap function and I don't understand the purpose of the double data type of long and 
the fact that it is also a reference.

Output:
In C++, a function parameter written as:
long long &exchanges
should be interpreted as:
‚úÖ A reference to a long long
More specifically:
long long ‚Üí the data type
& ‚Üí indicates this parameter is a reference
exchanges ‚Üí the name of the parameter
What it means
The function receives a reference to an existing long long variable, not a copy.
This allows the function to:
Modify the caller‚Äôs variable directly, and
Avoid copying large data types (not a big deal for long long, but standard practice).
Example
void updateCount(long long &exchanges) {
    exchanges += 10;   // Modifies the original variable
}

int main() {
    long long x = 5;
    updateCount(x);
    // x is now 15
}
Why use a reference?
To return multiple outputs from a function.
To modify an argument directly.
To avoid copying (more important for large structs/classes).
How it differs from pointers
void foo(long long* p); // must pass &variable
void foo(long long& r); // pass variable directly
References cannot be null, must bind to an object on initialization, and use simpler syntax.


Learned: I learned it is basically a type of integer. It can store larger numbers, guaranteed to be 64 bits wide. I also learned
it is important to keep the exchanges variable as a reference so we can edit the number directly rather than making multiple copies.
------------------------------------------------------------------------------------------------
Q: What does it mean if a function has the prefix "inline" before the return data type?
R: I am still writing my code/algorithim for the rowSwap function and I don't understand the purpose of the "inline" prefix at the beginning 
of helper function "inline int* rowPtr(int* data, int r, int C)".

Output:
In C++, putting the keyword inline before a function means:
It suggests to the compiler that the function‚Äôs code should be expanded at the call site instead of making a normal function call.
Example:
inline int add(int a, int b) {
    return a + b;
}
What ‚Äúinline‚Äù really means today
Historically, inline meant:
‚ÄúPlease replace calls to this function with the function‚Äôs code to avoid function call overhead.‚Äù
But modern compilers decide inlining automatically, so the keyword rarely affects performance.
What inline actually controls now
In modern C++, the most important meaning of inline is:
‚úÖ A function can have multiple definitions across different translation units, as long as they are identical.
That's why we use inline for:
Functions defined in header files
Templates (implicitly inline)
Small utility functions inside headers
Without inline, defining a function in a header would cause multiple-definition linker errors.
Summary
Effect	True today?	What it means
‚ÄúInline-expand this function for speed.‚Äù	‚ùå Not guaranteed	The compiler decides.
Allow multiple identical definitions across the program.	‚úÖ Yes	The real modern purpose.
Good for header-defined functions.	‚úÖ Yes	Used a lot for this.
Example in a header
// math_utils.h
inline int square(int x) {
    return x * x;
}
Simple explanation
inline used to mean ‚Äúoptimize by inlining‚Äù.
Today, it mainly prevents linker errors when a function is defined in a header.
If you'd like, I can explain:
Why inlining doesn't always improve performance
How linkers handle inline functions
constexpr vs inline functions

                                what are linker errors?
In C++, linker errors happen during the linking stage of building your program ‚Äî after compilation.
To understand linker errors, it helps to know the build steps:
1. Compiler
Each .cpp file is compiled separately into an object file (.o or .obj).
Compiler errors are things like:
‚Äúundefined type‚Äù
‚Äúmissing semicolon‚Äù
‚Äúno matching function call‚Äù
2. Linker
The linker takes all object files and combines them into the final executable.
This is where linker errors occur.
üîß What linker errors mean
Linker errors usually fall into two categories:
1. Undefined reference
The linker can‚Äôt find the actual definition (the code body) of a function or global variable that was declared and used.
Example:
// foo.h
void greet();   // declaration only

// main.cpp
#include "foo.h"
int main() {
    greet();     // we call it...
}
But if you forget to define greet() anywhere:
void greet(); // declaration only, no definition
The linker will error:
undefined reference to `greet()'
2. Multiple definitions
The linker finds more than one definition of the same function or global variable.
Example:
// utils.h
void hello() { cout << "Hello"; }  // BAD: definition in header!
If utils.h is included in 3 different .cpp files, the function is defined three times, causing:
multiple definition of `hello()'
Why?
Each .cpp file gets its own copy of the function.
How to fix?
Mark it as:
inline void hello() { ... }
or move the definition to a .cpp file.
üîß Why linking matters
Linking ensures:
All declarations you used have real definitions.
You don‚Äôt define things more than once.
All modules (object files) get combined into one final program.
Simple analogy
The compiler checks grammar in each chapter separately.
The linker checks that all chapters reference each other correctly:
If Chapter 2 refers to a character that is never introduced ‚Üí undefined reference.
If two chapters introduce the same character separately ‚Üí multiple definition.

Learned: Based on what ChatGPT said, it sounds like the "inline" prefix just prevents compilation errors if there are multiple
definition of the same function across multiple files. However, I am not sure I understand why this was put in for our case.
------------------------------------------------------------------------------------------------
Q:how is this returning the pointer to a specific row and col? // Return a pointer to row r 
(mutable) inline int* rowPtr(int* data, int r, int C) { return data + r * C; }?
R: I did not understand how data + r*C was acessing data in an array

Ouput:
We‚Äôll assume this function:
inline int* rowPtr(int* data, int r, int C) {
    return data + r * C;
}
And we‚Äôll use a 3√ó4 matrix stored in row-major order:
Row 0: 10 11 12 13
Row 1: 20 21 22 23
Row 2: 30 31 32 33
Stored as a 1-D array:
Index: 0  1  2  3   4  5  6  7   8  9  10 11
Value:10 11 12 13  20 21 22 23  30 31 32 33
Let:
int data[] = {
    10,11,12,13,
    20,21,22,23,
    30,31,32,33
};
C = 4 because there are 4 columns.
üî∑ Example 1 ‚Äî Get pointer to row 0
Input
rowPtr(data, 0, 4)
Calculation
Offset = 0 * 4 = 0
Output pointer
Points to data[0] (value 10)
Usage:
int* r0 = rowPtr(data, 0, 4);
r0[0] == 10
r0[1] == 11
r0[2] == 12
r0[3] == 13
üî∑ Example 2 ‚Äî Get pointer to row 1
Input
rowPtr(data, 1, 4)
Calculation
Offset = 1 * 4 = 4
Output pointer
Points to data[4] (value 20)
Usage:
int* r1 = rowPtr(data, 1, 4);
r1[0] == 20
r1[1] == 21
r1[2] == 22
r1[3] == 23
üî∑ Example 3 ‚Äî Get pointer to row 2
Input
rowPtr(data, 2, 4)
Calculation
Offset = 2 * 4 = 8
Output pointer
Points to data[8] (value 30)
Usage:
int* r2 = rowPtr(data, 2, 4);
r2[0] == 30
r2[1] == 31
r2[2] == 32
r2[3] == 33
üî∑ Example 4 ‚Äî Access a specific element using rowPtr
Suppose you want element at (r=1, c=2) (row 1, col 2):
Step 1: get row pointer
int* r1 = rowPtr(data, 1, 4);
Step 2: index into that row
int value = r1[2];
Result:
r1[2] == data[4 + 2] == data[6] == 22
üî∑ Example 5 ‚Äî Modify a row
int* r0 = rowPtr(data, 0, 4);
r0[2] = 999;
Now the array becomes:
10 11 999 13   20 21 22 23   30 31 32 33
üî∑ Example 6 ‚Äî Use it without storing the row pointer
Direct access:
int x = *(rowPtr(data, 2, 4) + 1);
Evaluates as:
row 2 ‚Üí start at data[8]
+1 ‚Üí data[9]
value = 31

Learned: I learned it is more of a syntax understanding. This function represents getting the first
element in a specific row of an array. C represents the number of col in the entire matrix, so by specifying
the row, you can get first element of each row. ChatGPT also showed me how to access specific elements
after specifying the row.
----------------------------------------------------------------------------------------------------
